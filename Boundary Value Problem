#The Boundary Value Problem requires us to find the initial values that will result in a predetermined final condition
#I explored two scenarios: a projectile only influenced by Earth's gravity, and a two-body problem using a body in space to alter a projectile's trajectory

#Part 1: Earth's Gravity

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.optimize import minimize

def projectile(t, u, angle, velocity):
    """Equations of motion"""
    x, y, vx, vy = u
    g = 9.8 

    dxdt = vx
    dydt = vy
    dvxdt = 0
    dvydt = -g

    return [dxdt, dydt, dvxdt, dvydt]

def wrapper_objective_function(params, target_coordinates, fixed_time_of_flight):
    """solving for optimized final coordinates"""
    angle, velocity = params
    u0 = [0, 0, velocity * np.cos(np.radians(angle)), velocity * np.sin(np.radians(angle))]
    sol = solve_ivp(projectile, [0, fixed_time_of_flight], u0, args=(angle, velocity), method='RK45', dense_output=True)
    
    final_x, final_y = sol.sol(fixed_time_of_flight)[:2]
    
    diff_coordinates = np.array([final_x - target_coordinates[0], final_y - target_coordinates[1]])
    
    return np.linalg.norm(diff_coordinates)

target_coordinates = [1, 1]

fixed_time_of_flight = 1.0 

initial_guess = [20, 10]  #[angle in degrees, velocity in m/s] - this guess will be optimized

result = minimize(wrapper_objective_function, initial_guess, args=(target_coordinates, fixed_time_of_flight), method='Nelder-Mead')

optimal_angle, optimal_velocity = result.x

print("Optimal Angle:", optimal_angle, "degrees")
print("Optimal Velocity:", optimal_velocity, "m/s")
print("Fixed Time of Flight:", fixed_time_of_flight, "seconds")

u0 = [0, 0, optimal_velocity * np.cos(np.radians(optimal_angle)), optimal_velocity * np.sin(np.radians(optimal_angle))] #putting the optimized values into the equations of motion array
sol = solve_ivp(projectile, [0, fixed_time_of_flight], u0, args=(optimal_angle, optimal_velocity), dense_output=True)

#Plotting the trajectory
t_plot = np.linspace(0, fixed_time_of_flight, 1000)
trajectory = sol.sol(t_plot)

plt.figure(figsize=(8, 6))
plt.scatter(trajectory[0], trajectory[1], label='Rocket Trajectory')
plt.scatter(*target_coordinates, color='red', s = 70, label='Target Coordinates')
plt.title('Projectile Motion')
plt.xlabel('Horizontal Distance (m)')
plt.ylabel('Vertical Distance (m)')
plt.legend()
plt.grid(True)
plt.show()


#Part 2: Two-Body Problem

#In this section I am launching a rocket in the direction of the Moon and seeing how the initial conditions affect the trajectory of the rocket

def gravity_assist(t, u):
    """Equations of motion"""
    x, y, vx, vy = u
    
    drdt = [vx, vy]
    
    G = 6.67430e-11
    M = 7.35e22
    
    r = np.sqrt(x**2 + y**2)
    dvdt = [-G * M * x / r**3, -G * M * y / r**3]
    return drdt + dvdt


#initial conditions
r0 = [1.0e6, 1.0e4]
v0 = [-1.0e4, -5.0e1]
u0 = r0 + v0 #initial state vector

t_span = [0, 200]  #simulation time (s)

#solve the differential equation
sol = solve_ivp(gravity_assist, t_span, u0, method='RK45', dense_output = True, max_step = 0.01)

#extract the trajectory
x_traj, y_traj = sol.y[0], sol.y[1]

plt.figure(figsize=(6, 4))
plt.scatter(x_traj, y_traj, label='Trajectory', color='blue')
plt.plot(0, 0, 'o', color='red', label='Moon')
plt.title('Rocket Trajectory')
plt.xlabel('Horizontal Distance (km)')
plt.ylabel('Vertical Distance (km)')
plt.legend()
plt.grid(True)
plt.show() #This plot shows me successfully turning a rocket around by slingshotting around the Moon

#Now increase the velocity in the negative-x direction and decrease the simulation time to see the rocket deviate course slightly, as opposed to slingshotting around:

#initial conditions
r0 = [1.0e6, 1.0e4]
v0 = [-1.0e5, -5.0e1]
u0 = r0 + v0 #initial state vector

t_span = [0, 20]  #simulation time (s)

#solve the differential equation
sol = solve_ivp(gravity_assist, t_span, u0, method='RK45', dense_output = True, max_step = 0.01)

#extract the trajectory
x_traj, y_traj = sol.y[0], sol.y[1]

plt.figure(figsize=(6, 4))
plt.scatter(x_traj, y_traj, label='Trajectory', color='blue')
plt.plot(0, 0, 'o', color='red', label='Moon')
plt.title('Rocket Trajectory')
plt.xlabel('Horizontal Distance (km)')
plt.ylabel('Vertical Distance (km)')
plt.legend()
plt.grid(True)
plt.show()
